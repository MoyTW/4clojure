;;;; 131 - Sum Some Set Subsets
 ;;; Scratch:;;   https://github.com/MoyTW/4clojure/blob/master/ScratchPaper/131-wip.clj
;; Original:
(fn __ [& args]
  (letfn [(power-set [trgt-st]
            (letfn [(break-up [s] (map #(disj s %) s))
                    (next-line [s] (set (mapcat break-up s)))]
              (loop [st #{trgt-st} pwr-st #{trgt-st}]
                (if (= st #{#{}}) pwr-st
                  (recur (next-line st) (apply conj pwr-st (next-line st)))))))]
    (let [[first-sum & rest-sums] (->> (map power-set args)
                                       (map #(remove empty? %))
                                       (map (fn [s] (map #(apply + %) s))) ; pretty ugly
                                       (map #(into #{} %)))]
      (if-let [result (some (fn [v] (every? #(contains? % v) rest-sums)) first-sum)]
        result
        false))))
;;   So, what we want to do is given sets of integers, find out the summations of
;; all subsets of each set. If there is one summation which is equal across all
;; sets, return true - otherwise return false.
;;   There's probably a more elegant way of approaching the problem than
;; "generate every possible subset of each set," but I can't think of what it
;; would be. You could try to do it setwise - find common ones between sets A
;; and B, then compare the common subsets with C, and so on, but, wait, no, that
;; would be a faster approach. If you find common subsets by exploding the set
;; into a power set, it'll be no more efficient if there is a match - but it
;; will be more efficient if there isn't.
;;   Not that there's any real efficiency concern here, but hey, it's an
;; exercise, and good habits and all.
;;   Anyways, we'll rewrite that part later. First, let's figure out what's going
;; on currently - and how it might be improved. First, we have a subfunction,
;; power-set, which was stolen from #85 (you can see the rewrite here:
;; https://github.com/MoyTW/4clojure/blob/master/UpdatedCommentedSolutions/83-86-updated.clj),
;; so I won't be covering that.
;;   The body of the solution is in the let. It takes the collection of sets,
;; explodes them into their power sets (removing the vestigal empty sets which
;; are generated by the power set - that's another thing that could be improved
;; on), then sums them all and returns the result in a collection of sets. It's
;; destructured into first-sum and rest-sums - which is actually very
;; misleading, because first-sum implies that it should be a singular value, but
;; it's really the first collection of sums!
;;   Then, in the if-let, it checks every member of the first set of sums against
;; the others, and if it returns, it's true. It has to manually return false if
;; it finds nothing because 4Clojure checks for equality with false instead of
;; logical false, so nil won't pass the tests. Boo.
;;   All right, so there are a couple of changes which could be made without
;; impacting the algorithm that I mentioned before. Also I've got a node next to
;; that map-in-map function saying that it's ugly. That looks like a good place
;; to use partial, I wonder if it'll improve it any?
(fn __ [& args]
  (letfn [(power-set [trgt-st]
            (letfn [(break-up [s] (map #(disj s %) s))
                    (next-line [s] (set (mapcat break-up s)))]
              (loop [st #{trgt-st} pwr-st #{trgt-st}]
                (if (= (next-line st) #{#{}})
                    pwr-st
                    (recur (next-line st) (apply conj pwr-st (next-line st)))))))]
    (let [[first-sums & rest-sums] (->> (map power-set args)
                                        (map (fn [s] (map (partial apply +) s)))
                                        (map #(into #{} %)))]
      (if-let [result (some (fn [v] (every? #(contains? % v) rest-sums)) first-sums)]
        result
        false))))
;;   No, not really, but I rarely use partial so I should get in practice where I
;; can. And by rarely, I mean never.
;;   Anwyays, that's all well and good, but it explodes every set, every time.
;; How about restructuring so it explodes sets lazily, and early terminates if a
;; set shares no summed subsets with its adjacent set?
(fn __ [& args]
  (letfn [(power-set [trgt-st]
            (letfn [(break-up [s] (map #(disj s %) s))
                    (next-line [s] (set (mapcat break-up s)))]
              (loop [st #{trgt-st} pwr-st #{trgt-st}]
                (if (= (next-line st) #{#{}})
                    pwr-st
                    (recur (next-line st) (apply conj pwr-st (next-line st)))))))
          (compare [sums next-set]
            (if (not-empty sums)
                (let [next-sums (into #{} (map (partial apply +) (power-set next-set)))
                      matches (clojure.set/intersection sums next-sums)]
                  matches)))]
    (if-let [result (not-empty (reduce compare (into #{} (map (partial apply +) (power-set (first args)))) (rest args)))]
        true
        false)))
;;   Well, it works and all, but that's pretty ugly and inelegant. I mean, look
;; at those chains! Give me a moment to tidy up:
(fn __ [& args]
  (letfn [(power-set [trgt-st]
            (letfn [(break-up [s] (map #(disj s %) s))
                    (next-line [s] (set (mapcat break-up s)))]
              (loop [st #{trgt-st} pwr-st #{trgt-st}]
                (if (= (next-line st) #{#{}})
                    pwr-st
                    (recur (next-line st) (apply conj pwr-st (next-line st)))))))
          (to-sums [st]
            (into #{} (map (partial apply +) (power-set st))))
          (compare [sums next-set]
            (if (not-empty sums)
                (clojure.set/intersection sums (to-sums next-set))))]
    (if-let [result (not-empty (reduce compare (to-sums (first args)) (rest args)))]
        true
        false)))
;;   You can mix and match depending on your preference for tiny functions versus
;; blocks of chained calls, or you could use the chaining operators, but that's
;; a pretty easy-to-follow function now, I think. It still has that hideous
;; recur, though.
        
;; 132 - Insert between two items
 ;;; Scratch:;;   https://github.com/MoyTW/4clojure/blob/master/ScratchPaper/132-wip.clj
;; Original:
; Hey what happens if you run (__ = :eq [1 2 2 1]) do you think?
(fn __ [pred val coll]
  (mapcat #(if (pred %1 %2) [%1 val] [%1])
          coll
          (concat (rest coll) [(first coll)])))
;;   So, there's a fatal flaw in this code snippet. Can you spot it?
;;   First, the problem description. The function should insert val in between
;; every two items which satisfy pred. So! Have you spotted the error yet?
;;   If you haven't, go ahead and run (__ = :eq [1 2 2 3 3 4 5 1]) and see what
;; pops out. That's right, it's checking the last against the first. Why? Well,
;; the algorithm basically does a one-shift on the targeted collection, then
;; runs down the original and one-shifted versions, calling pred in succession.
;; If it finds that pred is satisfied, it spits out the given value in between
;; the two. However, this approach runs into a problem when it reaches the end
;; of the collection, because map ends when any of the given collections are
;; consumed - so we lose one data member by shifting it over it terminates
;; early.
;;   My initial attempt to solve that was to get the last data member of the
;; collection and manually paste it on, but that's not even remotely lazy, it I
;; just shrugged and hacked it, leading to the flawed code right here. Good
;; coding practices right there, past-me. I must've been anxious to get this one
;; over with.
;; How might this be fixed?
;;   Really, adding *anything* is a bad idea, because you might just happen to
;; have a pred that checks for it. So we can't fix it by extending the shifted
;; collection, and I think that means the mapcat solution is effectively dead. I
;; mean, you could do something really, really, really silly and put in a check
;; that tries to remove the last member if it matches the assigned val, but you
;; might have a last member in the collection which happens to be val so you
;; also have to make sure you don't remove a legit value and that's a silly line
;; of thought.
;;   Why not just rewrite it with reduce?
;;   Oh, right, because laziness. Reduce doesn't mesh well with laziness. Now,
;; you could use a fairly straightfoward recursive solution, couldn't you:
(fn __ [pred val coll]
  (letfn [(doop [prev [fin & rin :as in]]
            (if (seq in)
                (if (pred prev fin)
                    (concat [val fin] (doop fin rin))
                    (cons fin (doop fin rin)))))]
    (if (seq coll)
        (cons (first coll) (lazy-seq (doop (first coll) (rest coll)))))))
;;   Why is this running into an integer overflow on the fib one? Hmm. That
;; doesn't seem right. The laziness should - hmm. Am I misunderstanding the
;; semantics of lazy-seq? I think I must be! What's going on here? Let me see...
;;   Oh.
(fn __ [pred val coll]
  (letfn [(doop [prev [fin & rin :as in]]
            (if (seq in)
                (if (pred prev fin)
                    (concat [val fin] (lazy-seq (doop fin rin)))
                    (cons fin (lazy-seq (doop fin rin))))))]
    (if (seq coll)
        (cons (first coll) (doop (first coll) (rest coll))))))
;;   Silly me, huh?